---
layout: page
title: Getting Started
permalink: /getting-started/
---

# Requirements

Behind the scenes, when you build a pipeline in LambdaCD, you are actually building a small app in clojure so you'll
need some tools:

* A recent [JDK](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html){:target="_blank"}
* [Leiningen](http://leiningen.org){:target="_blank"} as a build tool
* A decent editor. To get started, whatever you are comfortable with is fine. If you want to really dive in, consider
something with good Clojure support. [Cursive](https://cursiveclojure.com/userguide/){:target="_blank"} and
[Light Table](http://lighttable.com/){:target="_blank"} are popular choices, as are general purpose editors with Clojure
support.

# Get Started

{% highlight bash %}
$ lein new lambdacd my-first-pipeline
Generating fresh 'lein new' lambdacd project.

$ cd my-first-pipeline
$ lein run
[...]
11:51:18.690 [main] INFO  o.e.jetty.server.AbstractConnector - Started SelectChannelConnector@0.0.0.0:8080
11:51:18.690 [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED SelectChannelConnector@0.0.0.0:8080
11:51:18.691 [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.server.Server@cfe881a
Started server on port 8080
{% endhighlight %}

That's it. You just generated a first pipeline that runs on [http://localhost:8080](http://localhost:8080){:target="_blank"}
on your machine:

![Screenshot of the initial pipeline generated by the LambdaCD template]({{ "/img/getting-started/initial-pipeline.png" | prepend: site.baseurl }})

Click the arrow icon on the first step to trigger the pipeline. Now your pipeline runs, and you'll notice the steps getting
green or red one by one. Click on any of the steps the view the steps output.

# A quick tour around the code

So let's take a look what we just created. If you don't know Clojure yet, don't be scared if some of the syntax looks
unfamiliar. Your first steps won't require you to be a Clojure ninja.

{% highlight bash %}
$ tree
  .
  ├── README.md
  ├── project.clj
  └── src
      └── my_first_pipeline
          ├── pipeline.clj
          └── steps.clj
{% endhighlight %}


## `project.clj`

This is a Leiningen project definition. You declare your dependencies here and other things about your project.
Dont' worry about it for now.

## `my_first_pipeline`

Your pipeline code lives in this namespace. By default, we split up the structure of the pipeline and the build steps
but you can organize your code any way you want.

### `pipeline.clj`

This file is contains the initialization and the structure of the pipeline.

Like any other clojure code file, it starts with the namespace declaration and imports of required namespaces:

{% highlight clojure %}
(ns my-first-pipeline.pipeline
  (:use [lambdacd.steps.control-flow]
        [lambdacd.steps.manualtrigger]
        [my-first-pipeline.steps])
  (:require
        [ring.server.standalone :as ring-server]
        [lambdacd.ui.ui-server :as ui]
        [lambdacd.runners :as runners]
        [lambdacd.util :as util]
        [lambdacd.core :as lambdacd]
        [clojure.tools.logging :as log])
  (:gen-class))
{% endhighlight %}

More importantly, we define a constant `pipeline-def` which holds your pipelines structure:
{% highlight clojure %}

(def pipeline-def
  `(
    wait-for-manual-trigger
    some-step-that-does-nothing
    (in-parallel
      some-step-that-echos-foo
      some-step-that-echos-bar)
    wait-for-manual-trigger
    some-failing-step))
{% endhighlight %}


It also includes the `-main` entrypoint to your application lives, taking care of wiring everything together,
setting up configuration and starting pipeline and server:

{% highlight clojure %}
(defn -main [& args]
      (let [home-dir (util/create-temp-dir)
            config { :home-dir home-dir :dont-wait-for-completion false}
            pipeline (lambdacd/assemble-pipeline pipeline-def config)
            app (ui/ui-for pipeline)]
           (log/info "LambdaCD Home Directory is " home-dir)
           (runners/start-one-run-after-another pipeline)
           (ring-server/serve app {:open-browser? false
                                   :port 8080})))
{% endhighlight %}



### `steps.clj`

This file contains your custom build steps that were referenced in the pipeline structure you just saw.

Again, we start with the namespace header. Specifically, we import the `lambdacd.steps.shell` namespace under the name
`shell`. This provides LambdaCD support for executing commands on the shell.

{% highlight clojure %}
(ns my-first-pipeline.steps
  (:require [lambdacd.steps.shell :as shell]))
{% endhighlight %}

Next, we'll define the simplest possible build step. Every build step is a clojure function (that's what the `defn` is
all about) with two parameters, `args` and `ctx`. `args` is how build steps exchange information with each other. `ctx`
contains the build steps LambdaCD context. It provides some functionality you'll need as your build steps get more advanced.
For now, all you'll need to know is that some things (like shell support) require you to pass this on.

Apart from taking in two arguments, each build step is required to return a map that contains at least if it succeeded or not.
All in all, this is the simplest successful build step you could write:

{% highlight clojure %}
(defn some-step-that-does-nothing [args ctx]
  {:status :success})
{% endhighlight %}

Most of the time though, library functions will take care of actually assembling all that for you, so for now, we are
just doing the most obvious thing to do in a build pipeline. We execute some shell commands:

{% highlight clojure %}
(defn some-step-that-echos-foo [args ctx]
  (shell/bash ctx "/" "echo foo"))

(defn some-step-that-echos-bar [args ctx]
  (shell/bash ctx "/" "echo bar"))

(defn some-failing-step [args ctx]
  (shell/bash ctx "/"
                  "echo \"i am going to fail now...\""
                  "exit 1"))
{% endhighlight %}
