---
layout: page
title: Getting Started
permalink: /getting-started/
---

# Requirements

Behind the scenes, when you build a pipeline in LambdaCD, you are actually building a small app in clojure so you'll
need some tools:

* A recent [JDK](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html){:target="_blank"}
* [Leiningen](http://leiningen.org){:target="_blank"} as a build tool
* A decent editor. To get started, whatever you are comfortable with is fine. If you want to really dive in, consider
something with good Clojure support. [Cursive](https://cursiveclojure.com/userguide/){:target="_blank"} and
[Light Table](http://lighttable.com/){:target="_blank"} are popular choices, as are general purpose editors with Clojure
support.

# Get Started

{% highlight bash %}
$ lein new lambdacd my-first-pipeline
Generating fresh 'lein new' lambdacd project.

$ cd my-first-pipeline
$ lein run
[...]
11:51:18.690 [main] INFO  o.e.jetty.server.AbstractConnector - Started SelectChannelConnector@0.0.0.0:8080
11:51:18.690 [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED SelectChannelConnector@0.0.0.0:8080
11:51:18.691 [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.server.Server@cfe881a
Started server on port 8080
{% endhighlight %}

That's it. You just generated a first pipeline that runs on [http://localhost:8080](http://localhost:8080){:target="_blank"}
on your machine:

![Screenshot of the initial pipeline generated by the LambdaCD template]({{ "/img/getting-started/initial-pipeline.png" | prepend: site.baseurl }})

Click the arrow icon on the first step to trigger the pipeline. Now your pipeline runs, and you'll notice the steps getting
green or red one by one. Click on any of the steps the view the steps output.

# A quick tour around the code

So let's take a look what we just created. If you don't know Clojure yet, don't be scared if some of the syntax looks
unfamiliar. Your first steps won't require you to be a Clojure ninja.

{% highlight bash %}
$ tree
  .
  ├── README.md
  ├── project.clj
  └── src
      └── my_first_pipeline
          ├── pipeline.clj
          └── steps.clj
{% endhighlight %}


## `project.clj`

This is a Leiningen project definition. You declare your dependencies here and other things about your project.
Dont' worry about it for now.

## `my_first_pipeline`

Your pipeline code lives in this namespace. By default, we split up the structure of the pipeline and the build steps
but you can organize your code any way you want.

### `pipeline.clj`

This file is contains the initialization and the structure of the pipeline.

Like any other clojure code file, it starts with the namespace declaration and imports of required namespaces:

{% highlight clojure %}
(ns my-first-pipeline.pipeline
  (:use [lambdacd.steps.control-flow]
        [lambdacd.steps.manualtrigger]
        [my-first-pipeline.steps])
  (:require
        [ring.server.standalone :as ring-server]
        [lambdacd.ui.ui-server :as ui]
        [lambdacd.runners :as runners]
        [lambdacd.util :as util]
        [lambdacd.core :as lambdacd]
        [clojure.tools.logging :as log])
  (:gen-class))
{% endhighlight %}

More importantly, we define a constant `pipeline-def` which holds your pipelines structure:
{% highlight clojure %}

(def pipeline-def
  `(
    wait-for-manual-trigger
    some-step-that-does-nothing
    (in-parallel
      some-step-that-echos-foo
      some-step-that-echos-bar)
    wait-for-manual-trigger
    some-failing-step))
{% endhighlight %}


It also includes the `-main` entrypoint to your application lives, taking care of wiring everything together,
setting up configuration and starting pipeline and server:

{% highlight clojure %}
(defn -main [& args]
      (let [home-dir (util/create-temp-dir)
            config { :home-dir home-dir :dont-wait-for-completion false}
            pipeline (lambdacd/assemble-pipeline pipeline-def config)
            app (ui/ui-for pipeline)]
           (log/info "LambdaCD Home Directory is " home-dir)
           (runners/start-one-run-after-another pipeline)
           (ring-server/serve app {:open-browser? false
                                   :port 8080})))
{% endhighlight %}



### `steps.clj`

This file contains your custom build steps that were referenced in the pipeline structure you just saw.

Again, we start with the namespace header. Specifically, we import the `lambdacd.steps.shell` namespace under the name
`shell`. This provides LambdaCD support for executing commands on the shell.

{% highlight clojure %}
(ns my-first-pipeline.steps
  (:require [lambdacd.steps.shell :as shell]))
{% endhighlight %}

Next, we'll define the simplest possible build step. Every build step is a clojure function (that's what the `defn` is
all about) with two parameters, `args` and `ctx`. `args` is how build steps exchange information with each other. `ctx`
contains the build steps LambdaCD context. It provides some functionality you'll need as your build steps get more advanced.
For now, all you'll need to know is that some things (like shell support) require you to pass this on.

Apart from taking in two arguments, each build step is required to return a map that contains at least if it succeeded or not.
All in all, this is the simplest successful build step you could write:

{% highlight clojure %}
(defn some-step-that-does-nothing [args ctx]
  {:status :success})
{% endhighlight %}

Most of the time though, library functions will take care of actually assembling all that for you, so for now, we are
just doing the most obvious thing to do in a build pipeline. We execute some shell commands:

{% highlight clojure %}
(defn some-step-that-echos-foo [args ctx]
  (shell/bash ctx "/" "echo foo"))

(defn some-step-that-echos-bar [args ctx]
  (shell/bash ctx "/" "echo bar"))

(defn some-failing-step [args ctx]
  (shell/bash ctx "/"
                  "echo \"i am going to fail now...\""
                  "exit 1"))
{% endhighlight %}


## Checking out a git repo and doing some real work

Most build pipelines need to touch version control at some point. So let's see how we can wait for commits, check out a
repository and run some tests.

So let's create a new pipeline structure first:

{% highlight clojure %}
(def pipeline-def
  `(
    (either
      wait-for-manual-trigger
      wait-for-repo)
    (with-repo
          run-some-tests)))
{% endhighlight %}

A couple of things aren't there yet:

* `wait-for-repo` to wait for commits on a repository
* `with-repo` to check out the repository and run other steps on the checked out repository
* `run-some-tests` actually run some tests.

Let's get started!

First, let's pull in LambdaCDs Git support:

{% highlight clojure %}
(ns my-first-pipeline.steps
  (:require [lambdacd.steps.shell :as shell]
            [lambdacd.steps.git :as git]))
{% endhighlight %}

Also, let's put the repository information into a constant so we can use them in both git-related steps we are going to
build. We'll use LambdaCDs own repository here as an example:

{% highlight clojure %}
(def repo-uri "https://github.com/flosell/lambdacd.git")
(def repo-branch "master")
{% endhighlight %}

Now that we have everything we need set up, let's create the build steps:

{% highlight clojure %}
(defn wait-for-repo [args ctx]
  (git/wait-for-git ctx repo-uri repo-branch))

(defn with-repo [& steps]
  (git/with-git repo-uri steps))
{% endhighlight %}

`wait-for-repo` is more or less straightforward stuff you already know, `with-repo` looks a bit odd, right? Didn't I say
that every build-steps needs to have two parameters, `args` and `ctx`? Yes, but then `with-repo` isn't a normal build-step
when you look at how it's being used in the pipeline structure: It's being called within the pipeline structure, takes
any number of build steps and returns a build step that'll run it's children within the git repository context.

Now, all that's left is how to get the tests running. The first step is easy, you have seen how to call something on the
shell before. But where to find the git repository `with-git` checked out for us? Well remember I mentioned before that
`args` is how build steps communicate with each other? `with-git` does just that. It puts the working directory into the
childs `args` under the key `:cwd`.

{% highlight clojure %}
(defn run-some-tests [args ctx]
  (shell/bash ctx (:cwd args) "./go test-clj"))
{% endhighlight %}

And that's all you need. `lein run` your pipeline again and see the it all work.


# Where to go from here?

* Find out [how to do implement some common, more advanced use cases](https://github.com/flosell/lambdacd/blob/master/doc/howto.md)
* Read the [FAQs](https://github.com/flosell/lambdacd/blob/master/doc/FAQ.md)
* Go through a [comprehensive walkthrough](https://github.com/flosell/lambdacd/blob/master/doc/walkthrough.md),
  implementing a complete delivery pipeline and going deeper into the details of LambdaCD